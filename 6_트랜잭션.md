# 트랜잭션

기본 문법에 넣으려 했으나 심도있는 내용이 많아서 분리했다. SQL Server에만 해당되는 내용이 있을 수 있으니  
주의하자.

## 정의

트랜잭션은 작업의 단위이다. 트랜잭션이 성공적이라면 해당 트랜잭션내의 모든 데이터 수정사항은 모두 커밋되어 DB에 영구적이 된다.  
반대로 실패한다면 취소나 롤백 되어야 하므로 모든 수정사항은 지워진다. SQL Server에서 다음과 같은 트랜잭션 모드에서 동작한다.

- 오토 커밋 트랜잭션: 각 구문이 트랜잭션이다. 성공하면 커밋, 에러로 인해 실패하면 롤백한다. 특별히 묵시적, 명시적 모드로 오버라이드 되지 않는 이상 이 모드를 기본으로 동작한다.
- 명시적 트랜잭션 : 명시적으로 BEGIN TRANSACTION라는 구문으로 시작하여 명시적으로 COMMIT or ROLLBACK으로 끝난다.
- 묵시적 트랜잭션 : 이전 트랜 잭션이 끝나면 새 트랜잭션이 묵시적으로 시작된다. 허나 각 트랜잭션은 명시적으로 COMMIT or ROLLBACK으로 끝나야 한다.
- 배치 범위 트랜잭션

### 문법

```sql
BEGIN TRANSACTION;
DELETE FROM HumanResources.JobCandidate
    WHERE JobCandidateID = 13;
COMMIT;

CREATE TABLE ValueTable (id INT);
BEGIN TRANSACTION;
    INSERT INTO ValueTable VALUES(1);
    INSERT INTO ValueTable VALUES(2);
ROLLBACK;

BEGIN TRANSACTION @TranName;
USE AdventureWorks2022;
DELETE FROM AdventureWorks2022.HumanResources.JobCandidate
    WHERE JobCandidateID = 13;

COMMIT TRANSACTION @TranName;
GO
```

### ACID 속성

트랜잭션 전후의 DB의 일관성을 지속하기 위해 ACID라는 속성들이 반드시 지켜져야 한다.  
![ACID속성](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191121102921/ACID-Properties.jpg)

- 원자성 : 전체 트랜잭션이 한번에 발생하거나 발생하지 않아야한다.
- 일관성 : DB는 트랜잭션 전후에도 일관되어야 한다. 상태 변경후 해당 데이터에 대한 기존 규칙과 제약들을 보존한다.
- 고립성 : 다수의 트랜잭션은 서로의 간섭없이 개별적으로 이루어저야한다.
- 지속성 : 시스템이 에러가 발생하더라도 성공적으로 실행 된 트랜잭션의 사항들은 반영된다.

### 락킹과 로우 버저닝

DB엔진은 여러 사용자가 데이터에 동시에 접근할 때 트랜잭션의 무결성과 DB의 일관성을 보장하기위해 다음과 같은 기법을  
사용한다.

- 락킹(Locking) : 각 트랜잭션은 트랜잭션이 의존하는 행, 페이지, 테이블 같은 자원에 서로다른 종류의 락을 요청한다. 락은  
  문제가 될 수도 있는, 자원을 수정 하려는 다른 트랜잭션을 블락한다. 각 트랜잭션은 자원에 대한 종속성이 없어질때 락을 푼다.
- 로우 버저닝(Row versioning) : 고립 레벨(Isolation Level)에 기반한 로우 버저닝이 쓰이면 DB엔진은 수정 된 각 행의 버전들을  
  유지한다. 앱 측에서 모든 읽기를 락으로 보호하는 대신에 트랜잭션 또는 구문이 시작 될 당시의 데이터를 보기 위해 행의 특정 버전
  을 사용 할 것을 명시 할 수 있다. 이를 통해 읽기 작업이 다른 트랜잭션을 블락할 경우의 수를 대폭 줄인다.

이 두 기법을 통해 유저들이 커밋되지 않은 데이터를 일거나 다수의 유저들이 같은 데이터를 동시에 바꾸려는 것을 예방 할 수 있다.  
애플리케이션 측에서는 트랜잭션 다른 트랜잭션으로 부터의 수정으로부터 트랜잭션을 보호하는 레벨인, 고립 레벨을 선택 할 수 있다.

### 동시성으로 인한 효과

만약 DB가 동시성에 대한 제어를 적절히 하지 못한다면 다음과 같은 부수 효과들이 나타난다.

- 업데이트 손실 : 두 개이상의 트랜잭션이 동일한 행에 기존 값에 기반하여 갱신할 경우 발생한다. 각 트랜잭션이 서로 인지를 못하기에  
  마지막 갱신이 다른 트랜잭션에 의한 갱신을 덮어 씐다. 이 경우 다른 한쪽에서 작업을 마치고 커밋할 떄까지 접근을 못하게 하면 해결  
  가능하다.
- 커밋 되지 않은 데이터 의존(더티 리드) : 두번쨰 트랜잭션이 다른 트랜잭션에 의해 갱신 되고 있는 행을 읽을 때 발생한다. 두 번쨰  
  트랜잭션은 아직 커밋되지 않은 데이터를 읽고 있고 이는 갱신 작업 중인 트랜잭션에 의해 바뀔 수 있다. 다른 한쪽에서 수정과 커밋을  
  마칠 때까지 다른 곳에서 읽기를 못 하게함으로써 막을 수 있다.
- 비일관적 분석(반복 불가능한 읽기) : 두 번쨰 트랜잭션이 같은 행을 여러번 접근하나 매번 다른 값을 읽어 들이면서 발생한다. 다른 트랜잭션이 두 번째 트랜잭션이 읽고 있는 데이터를 바꾸고 있다는 점에서 더티 리드와 유사하다. 하지만, 이 경우 두 번쨰 트랜잭션에  
  의해 읽혀지는 데이터는 커밋된 데이터이다. 또한 동일 행에 대해 다수의 읽기를 수반하는 데, 읽을 떄마다 다른 트랜잭션에 의해 값이  
  달라진다. 이는 읽기가 진행 되는 동안 쓰기를 금지함으로써 막을 수 있다.
- 팬텀 읽기 : 동일한 쿼리가 실행되지만 두번쨰 쿼리의 반환 결과가 다른 경우를 나타 낸다. 다음과 같은 경우를 가정해보자.

  ```sql
  --Transaction 1
  BEGIN TRAN;

  SELECT ID
  FROM dbo.employee
  WHERE ID > 5 AND ID < 10;

  --The INSERT statement from the second transaction occurs here.

  SELECT ID
  FROM dbo.employee
  WHERE ID > 5 and ID < 10;

  COMMIT;

  --Transaction 2
  BEGIN TRAN;
  INSERT INTO dbo.employee (Id, Name)
  VALUES(6 ,'New');

  COMMIT;
  ```

  트랜잭션에의해 같은 읽기 작업이 두번 실행 되지만 중간에 두번째 트랜잭션에 의해 INSERT문이 실행되면 결과가 달라 질 수 있다.

### 동시성의 종류

동시성 제어 이론은 제어 방식에 따라 두 부류로 나뉜다.

- 비관적 동시성 제어 : 다른 트랜잭션에 영향을 주지 않게 데이터를 수정하는 트랜잭션을 락으로 방지한다. 락을 야기하는 트랜잭션이  
  락을 풀 때까지 해당 락과 충돌하는 동작하는 다른 트랜잭션은 멈춘다.
- 낙관적 동시성 제어 : 트랜잭션이 읽기 작업시 데이터를 락하지 않는다. 하지만 트랜잭션이 데이터를 갱신하면 시스템이 읽기 후에  
  다른 트랜잭션이 데이터를 바꾸었는 지 확인한다. 만약 그렇다면 에러가 발생한다. 에러를 받은 트랜잭션은 롤백하고 다시 시작한다.

DB에서는 두 기법 모두 지원한다. 사용자가 어떤 방식을 사용 할 지는 트랜잭션 고립 레벨과 커서에대한 동시성 옵션에 달렸다.  
TSQL문으로 이들 속성을 정의 가능하다.

### 고립성 레벨

트랜잭션은 한 트랙잭션이 다른 트랜잭션의 데이터 수정으로부터 어느 정도까지 격리 되어야하는 지를 고립레벨로 명시 할 수 있다.  
고립 레벨은 동시성의 부수 효과로써 정의 된다. 고립성 레벨은 다음 사항들을 제어 한다.

- 읽기 시에 락이 획득 되어야하는 지, 그리고 어떤 타입의 락이 요청 되어야 하는 지 여부
- 읽기 락이 얼마나 소유되어야하는 지 여부
- 다른 트랜잭션에 의해 수정된 행에 대한 읽기 작업이 해당 행에 대한 락이 풀릴 떄까지 블락 되는 지, 해당 트랜잭션 혹은 구문 실행 시에 존재 했던 행의 커밋 버전을 가져 오는 지, 아니면 커밋 되지 않은 데이터 수정본을 읽어 오는 지 여부

고립 수준이 낮으면 동시에 접근 하는 트랜잭션들의 능력을 향상 시키지만 동시성 부수 효과 또한 더 많이 야기한다. 반대로 수준이 높다면  
동시성 부수효과는 덜 나타지만 더 많은 시스템 자원을 요구하고 서로 블락할 경우를 증가시킨다. ISO기준에 따른 고립수준은 다음과 같다.

- READ UNCOMMITTED : 가장 낮은 고립수준. 오로지 물리적으로 비일관적인 데이터가 읽히지 않을 정도만 보장한다. 더티 읽기가 허용되어  
  다른 트랜잭션에 의해 만들어진, 아직 커밋 되지 않은 변경을 볼수도 있다.
- READ COMMITTED : 첫번쨰 트랜잭션이 완료할 떄까지 기다리지 않고 다른 트랜잭션에 의해 읽혀졌던 데이터를 읽도록 허용한다. DB엔진은  
  쓰기 락은 트랜잭션의 끝까지 소유하나 읽기 락은 읽자마자 푼다. DB엔진의 기본 수준이다.
- REPEATABLE READ : DB엔진은 트랜잭션의 끝까지 해당 데이터에 대한 읽기 락과 쓰기 락 모두 소유한다. 허나 범위 락이 관리 되지 않아  
  팬텀 읽기가 발생할 수도 있다.
- SERIALIZABLE : 가장 높은 고립수준. DB 엔진은 트랜잭션의 끝까지 해당 데이터에 대한 읽기 락과 쓰기 락 모두 소유한다. 팬텀 읽기를 방지하기 위해 범위 락은 SELECT문이 WHERE문을 사용할 때 얻어 진다.

![고립성 레벨 요약표](https://media.geeksforgeeks.org/wp-content/cdn-uploads/transactnLevel.png)

### 효율적인 트랜잭션 작성

트랜잭션은 되도록이면 짧게 하는 게 중요한데 트랜잭션이 시작되면 DBMS는 ACID 속성 유지를 위해 트랜잭션의 끝까지 자원을 잡고 있을 수  
밖에 없다. 데이터가 수정되면 수정된 행은 다른 트랜잭션이 이를 읽는 것을 방지하기 위해 락으로 보호 되어야하며 락은 트랜잭션이 커밋 되거나 롤백 될 떄까지 소유 된다. 고립 수준에 따라 SELECT문이 락을 요구 할 수도 있다. 툭히 다수의 유저가 사용하는 시스템이라면 트랜  
잭션은 락으로 인한 경합을 줄이기 위해 최대한 짧게 작성해야한다.

### 트랜잭션 처리 중 에러

- 만약 에러가 트랜잭션의 성공을 막는다면 DB엔진은 자동으로 롤백하고 관련 자원을 해제한다.
- 만약 DB엔진에 대한 클라이언트 네트워크 연결이 끊기면 해당 연결에 남은 트랜잭션은 모두 롤백 된다.
- 만약 클라이언트측 어플리케이션이 실패하거나 클라이언트 컴퓨터가 종료된다면 이 또한 연결을 끊으므로 남은 트랜잭션을 롤백한다.
- 만약 클라이언트가 연결을 끊는 다면 남은 트랜잭션을 롤백한다.

만약 런타임 에러가 배치 내에서 발생하면 DB의 기본 동작은 에러를 야기한 해당 구문만 롤백한다. 이 행태도 SET XACT_ABORT ON구문  
으로 바꿀 수 있다. SET XACT_ABORT ON 실행하면 에러 발생시 현재 트랜잭션을 자동 롤백한다. 컴파일 에러는 해당 되지 않는다.

에러 발생시 적절한 조치(COMMIT, ROLLBACK)이 어플리케이션 코드에 포함되어 있어야한다. TSQL에서 TRY_CATCH구문을 지원한다.

자동 커밋 모드에서 가끔 보면 DB엔진이 한 구문 말고 전체 배치를 롤백한 것처럼 보일 떄가 있다. 이는 에러가 컴파일 에러일떄 발생  
한다. 컴파일 에러는 DB엔진이 실행 계획을 만드는 것을 막으므로 배치 내의 어느것도 실행 될 수 없다.

### 트랜잭션 로그 아키텍쳐

SQL 서버는 모든 트랜잭션과 DB수정 사항을 기록하는 트랜잭션 로그를 가지고 있다. 이는 DB의 중요 구성요소로 만약 시스템이 실패하면  
다시 일관성있는 상태로 복구 하기 위해 필요해 질 수 있다.

#### 참조

- [MSDN : 트랜잭션](https://learn.microsoft.com/en-us/sql/t-sql/language-elements/transactions-transact-sql?view=sql-server-ver16)
- [MSDN : Transaction locking and row versioning guide](https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver16)
- [MSDN : 트랜잭션 로그 아키텍쳐](https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-log-architecture-and-management-guide?view=sql-server-ver16)
