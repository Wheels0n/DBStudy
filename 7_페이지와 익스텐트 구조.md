# 페이지와 익스텐트 구조

인덱스 개념에 페이지 언급이 많이 되어서 한번 제대로 짚고 넘어가려한다.

## 페이지와 익스텐트

sql서버에서 데이터 저장공간의 기본적인 단위는 페이지이다. 데이터 파일(.mdf 나 .ndf)에 할당된 디스크 공간 논리적으로  
0에서n까지 연속적으로 넘버링된 페이지들로 나뉜다. 디스크 IO 작업은 페이지 레벨에서 실행된다. 즉 SQL 서버는 전체 데이터  
페이지들을 읽거나 쓴다.

익스텐트(extent)는 물리적으로 연속적인 8개의 페이지 집합으로 페이지들을 효율적으로 관리하기 위해 사용된다. 모든 페이지들은  
익스텐트로 구성된다.

### 페이지

보통 책에서 모든 내용은 페이지에 쓰인다. 이처럼 SQL서버는 모든 데이터 행을 페이지에 쓰고 이 페이지들은 모두 8KB로 같은 크기다.  
책에서 대부분의 페이지가 데이터(책의 주 내용)를 담고 어떤 페이지는 책에 대한 메타데이터(예를 들면 목차나 색인)를 담는다. SQL도  
다를 게 없다. 대부분의 페이지가 사용자에 의해 저장된 실제 데이터 행을 담는다. 이런 페이지들은 데이터 페이지 그리고 텍스트/이미지  
페이지라고 한다. 인덱스 페이지는 데이터가 어디있는 지 에 대한 인덱스를 담는다. 마지막으로 데이터 구성에 대한 메타 데이터를 담는 시스템 페이지가 있다.

각 페이지는 페이지에 대한 시스템 정보를 담는 96바이트 짜리 헤더로 시작된다. 이 정보에는 페이지 번호, 타입, 여유 공간, 그리고  
페이지를 가지는 오브젝트에 대한 할당 유닛 ID를 담는다.

![페이지 구조 다이어그램](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/page-architecture.svg?view=sql-server-2017)

데이터 행들은 페이지에 헤더에 바로 이어서 연속적으로 담긴다. 행 오프셋 테이블은 페이지 끝에서 시작하고 각 오프셋 테이블은 페이지의  
각 행에 대한 엔트리 값을 가진다. 각 오프셋은 페이지의 시작으로부터 행의 첫번쨰 바이트가 얼마나 떨어져있는 지를 저장한다. 고로 오프  
셋 테이블의 기능은 SQL서버가 페이지 내의 행들을 빨리 찾기 위해 존재한다. 오프셋 테이블의 엔트리들은 페이지내의 행들의 순서와 반대이다.

### 큰 행 지원

행은 페이지의 크기를 늘릴수 없다. 하지만 행의 일부가 페이지로부터 옮겨 질수 있어서 행이 커질 수 는 있다. 하나의 행의 데이터와 오버헤드의 최대 크기는 8060 바이트이다. 이는 텍스트/이미지 페이지 타입에 저장된 데이터를 포함하지 않는다.

varchar, nvarchar, varbinary, 또는 sql_variant 타입의 컬럼을 가진 테이블에 대해서 이 조건이 완화 된다. 만약 제한을 넘기면  
SQL서버가 동적으로 하나 이상의 가변 길이 컬럼을 가장 큰 컬럼부터 ROW_OVERFLOW_DATA 할당 유닛에 있는 페이지로 옮긴다.

이는 삽입 갱신 연산이 최대 행의 크기를 넘기게 할 떄마다 이루어진다. 컬럼이 ROW_OVERFLOW_DATA 할당 유닛에 있는 페이지로 옮길 때  
원본 페에지에 대한 24바이트짜리 포인터가 할당 유닛에 유지 된다. 후에 이루어진 연산이 행의 크기를 줄이면 다시 원본 페이지로 컬럼을  
옮긴다.

### 행 오버플로우 고려사항

행은 여러 페이지에 있을 수 없고 가변 데이터 타입의 필드들의 총 크기가 8060바이트 제한을 넘길 수 있다. 고로 다음을 고려해야한다.

- 큰 레코드들을 다른 페이지로 옮기는 건 레코드가 갱신되어 길어지면 동적으로 일어난다. 레코드를 짧게 하는 갱신이 일어나면 다시 원래  
  페이지로 옮겨진다. 행 오버플로우가 있는 레코드에 대한 정렬 또는 조인 같은 셀렉트 문은 이런 레코드들이 동기적으로 처리되어야 해서 처리 시간을 지연시킬 수 있다. 고로 오버플로우 될 것같은 행들의 비율과 이들이 질의 될 비율을 고려해야한다. 만약 행 오버 플로우 데이터의 다수 행에 빈번한 질의가 이루어진다면 정규화를 고려해봐야 한다.

- 개별 컬럼은 여전히 8000바이트 이내에 들어야한다. 오직 컬럼 길이의 총합이 8060바이트를 넘을 수 있다.
- 다른 데이터 타입의 총합은 무조건 8060바이트 제한에 들어야한다. 큰 오브젝트 데이터는 이 제한에서 배제된다.
- 클러스터 인덱스의 키 컬럼으로 일부 데이터가 ROW_OVERFLOW_DATA 할당 유닛에 있는 varchar 컬럼을 가질 수 없다.
- 행 오버플로우가 난 컬럼을 넌클러스터 인덱스의 컬럼으로 쓸 수 있다.

### 익스텐트

익스텐트는 공간이 관리되는 기본 단위이다. 8개의 물리적으로 연속된 페이지로 구성되어 있다. MB당 16개의 익스텐트가 있는 셈이다.

![익스텐트 종류](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/extents.svg?view=sql-server-2017)

- 균등한(Uniform) 익스텐트는 하나의 개체에 소유 된다. 모든 페이지가 오로지 소유하는 오브젝트만이 사용가능 하다.
- 복합(Mixed) 익스텐트는 최대 8개의 오브젝트까지 공유 가능하다. 각각의 페이지는 서로 다른 오브젝트에 의해 소유 될 수 있다.

SQL Server 2014 (12.x)까지는 DB엔진이 적은 데이터를 가진 테이블에 익스텐트 전체를 할당 하지 않았다. 새 테이블이나 인덱스는  
보통 복합 익스텐트로 부터 페이지를 할당 했다. 그러다가 8개의 페이지 까지 커지면 균등 익스텐트로 갈아탄다. 이미 충분히 데이터가  
있는 테이블에 인덱스를 만들면 인덱스에 대한 모든 할당은 균등 익스텐트가 되었다.

SQL Server 2014 (13.x)부터는 사용자 데이터 베이스와 tempdb에 대한 대부분의 할당에 대한 기본 동작은 균등 익스텐트를 쓰는 것이다.
master, msdb, 그리고 model DB는 여전히 이전의 행태를 유지 한다.

Starting with SQL Server 2012 (11.x)부터 sys.dm_db_database_page_allocations 함수로 페이지 할당 정보를 가져올 수 있다.

### 익스텐트 할당과 여유 공간 관리

익스텐트 할당과 여유공간을 추적하는 SQL서버 데이터 구조는 상대적으로 단순하다. 다음과 같은 장점이 있다.

- 자유공간에 대한 정보는 빽뺵하게 패킹 되어 상대적으로 적은 수의 페이지가 이 정보를 담고있다. 이는 할당 정보를 가져오기 위한 디스크 읽기 수를 줄인다. 또한 할당 페이지가 메모리 상에 남아 추가 읽기가 필요 없을 확률을 높여준다.
- 대부분의 할당정보는 같이 체이닝 되어 있지 않다. 각 페에지 할당/해제는 빠르게 수행된다. 이는 페이지 할당/해제를 하는 동시 작업의 경합을 줄인다.

### 익스텐트 할당 관리

SQL서버는 익스텐트 할당을 기록하기 위해 두 종류의 할당 맵을 사용한다.

- 전역 할당 맵(Global Allocation Map) : GAM페이지는 어떤 익스텐트가 할당 되었는 지 기록한다. 각 GAM은 6만4천개의 익스텐트, 약 4GB의 데이터를 다룬다. GAM은 다루는 구간의 각 익스텐트에 대해 한 개의 비트를 가진다. 1이면 해제, 0 이면 할당 상태를 나타낸다.
- 공유 전역 할당 맵(SGAM) : SGAM 페이지는 복합 익스텐트로써 현재 사용 되는 익스텐트들을 기록하고 적어도 하나의 미사용 페이지를 가진다. 각 SGAM은 6만4천개의 익스텐트, 약 4GB의 데이터를 다룬다. SGAM은 다루는 구간의 각 익스텐트에 대해 한 개의 비트를 가진다.  
  1이면 현재 복합 익스텐트로 사용중임며 여유 페이지가 있다는 뜻이고 0이면 복합 익스텐트로 사용되지 않거나, 복합 익스텐트이면서 모든 페이지가 사용되는 상태를 나타낸다.

### 여유 공간 추적

페이지 여유 공간(PFS) 페이지들은 각 페이지의 할당 상태를 기록하는 데 각 페이지의 할당 여부, 그리고 여유 공간 크기가 있다.  
PFS는 각 페이지당 1바이트를 가지며 페이지가 할당되 었는 지, 그렇다면 얼마나 차있는 지 기록한다.

오브젝트에 익스텐트가 할당되고 나면 DB엔진은 PFS페이지들을 익스텐트내 어떤 페이지들이 할당/해제 되었는 지 기록 한다. 이 정보는  
DB엔진이 새 페이지를 할당할떄 사용된다. 페이지 내의 여유 공간은 오로지 힙과 텍스트/이미지 페이지에 대해서만 유지 된다. 이는 DB 엔진이 새로 삽입 된 행을 담을 수 있는 여유 공간을 가진 페이지를 찾는 데 쓰인다. 인덱스의 경우 인덱스 키 값에 의해 새로 데이터 행을 삽입 할 지정이 결정 되기에 PFS가 추적되기를 요구하지 않는다.

새로 추가 되는 추적 구간 마다 새 PFS, GAM, 또는 SGAM페이지가 데이터 파일에 추가 된다. 고로 새 PFS페이지가 첫 PFS로부터 8088페이지 뒤에 추가되고, 추가 될 PFS페이지도 8088 페이지 구간 뒤에 온다. 예를 들면 1, 8088, 16167...

첫 GAM 페이지로 부터 6만 4천 익스텐트 후에 새 GAM페이지가 오고 이는 다음에 오는 6만4천개의 익스텐트를 추적한다. SGAM도 같은 방식이다.

![익스텐트 관리 페이지들](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/manage-extents.svg?view=sql-server-2017)

### 개체에 의해 사용되는 공간 관리

인덱스 할당 맵(Index Allocation Map) 페이지는 할당 유닛에 의해 사용되는 DB파일의 4GB 단위로 익스텐트를 매핑 한다. 할당유닛은  
세 종류가 있다.

- IN_ROW_DATA : 힙 또는 인덱스의 파티션을 가짐
- LOB_DATA : xml, varbinary(max), 또는 varchar(max) 같은 큰 오브젝트 데이터 타입을 가짐
- ROW_OVERFLOW_DATA: 8,060 바이트 제한을 초과한 varchar, nvarchar, varbinary, 또는 sql_variant 컬럼에 저장된 가변 길이 데이터를 저장

힙 또는 인덱스의 각 파티션은 적어도 하나의 IN_ROW_DATA 할당 유닛을 가진다. 힙과 인덱스 스키마에 따라 또한 LOB_DATA 또는 ROW_OVERFLOW_DATA를 포함 할 수 도 있다.

IAM페이지는 파일내의 4GB 범위를 다루며 이는 GAM과 SGAM페이지와 같은 범위다. 만약 할당 유닛이 하나 이상의 파일이나 하나의 파일에서 한 개 이상의 4GB 범위로 부터의 익스텐트를 가진다면 여러 IAM페이지로 링크 된 IAM채인이 있다. 고로 각 할당유닛은 익스텐트가 할당 된  
각 파일에 대해 적어도 하나의 IAM페이지를 가진다. 만약 하나의 IAM페이지가 기록 할 수 있는 범위를 넘기면 하나의 파일에 하나 이상의 IAM페이지가 있을 수도 있다.

![IAM페이지 다이어그램](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/iam-pages.svg?view=sql-server-2017)

IAM페이즌 각 할당 유닛에 요구 된 대로 할당 되고 파일 내의 아무 위치에 배치된다. sys.system_internals_allocation_units 시스템 뷰  
는 할당 유닛의 첫번쨰 IAM페이지를 가리킨다. 할당 유닛의 모든 IAM페이지는 IAM체인으로 링크되어있다.

![IAM페이지 체인](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/iam-chain.svg?view=sql-server-2017)

IAM페이지는 IAM페이지에 의해 매핑된 익스텐트의 범위의 시작 익스텐트를 가리키는 해더가 있다. 또한 IAM 페이지는 각 비트가 하나의 익스 텐트를 가리키는 커다란 비트맵이 있다. 비트 1은 첫번쨰, 비트 2는 두번쨰... 비트로 할당 유무를 나타낸다.

DB엔진이 새 행을 삽입하고 페이지에 남은 공간이 없으면 IAM과 PFS는 할당 할 새 페이지를 찾는다. DB엔진은 IAM페이지를 사용하여 할당된  
익스텐트들을 찾아 낸다. 각 익스텐트에 대해 DB엔진은 사용 가능한 페이지가 있는 지 PFS를 탐색 한다. 각 각의 IAM과 PFS페이지는 많은  
데이터 페이지를 커버해서 IAM과 PFS페이지 수는 적다. 이는 IAM, PFS가 보통 SQL서버 버퍼 풀의 메모리 안에 있어 탐색이 빠르단 뜻이다.  
인덱스의 경우 새행의 삽입 지점은 인덱스 키로 설정되지만 새 페이지가 필요하면 이전에 서술한 과정이 발생한다.

DB엔진은 기존 익스텐트에서 페이지에 새 행을 삽일 할 충분한 공간을 빠르게 구할 수 없을 때만 새 익스텐트를 할당한다.

### 비례 채우기 할당

DB엔진은 비례 채우기 할당 알고리즘으로 파일 그룹에서 이용가능한 익스텐트를 할당한다. 같은 파일그룹에서 하나의 파일이 다른 파일의  
여유 공간의 두배를 가진다면 그 파일에서 두 페이지가 할당되는 동안 다른 파일에서는 하나의 파일이 할당 된다.

### 수정된 익스텐트 추적

SQL 서버는 대량 복사 작업에의해 수정된 익스텐트와 최근의 풀 백업으로 인해 수정된 익스텐트 추적을 위해 두개의 내부 자료구조를 사용한다. 이 자료 구조는 차등 백업의 속도를 크게 향상시킨다. 또한, DB가 대량 로그 백업 모델을 사용할 때 대량 복사의 로깅을  
빠르게 한다. GAM과 SGAM 페이지들처럼 이들 구조는 각 비트가 하나의 익스텐트를 나타내는 비트맵이다.

- 차등 비트맵(Differenetial Changed Map) : BACKUP DATABASE 구문으로인해 바뀐 익스텐트들을 추적한다. 비트로 수정여부를 나타낸다.
  차등 백업은 어떤 익스텐트가 바뀌었는 지 DCM페이지를 읽는다. 이를 통해 차등 백업이 스캔해야하는 페이지 수를 줄인다. 차등 백업의  
  실행 시간은 수정된 익스텐트 수에 비례한다.
- 대량 수정 맵(Bulk Changed Map) : BACKUP LOG 구문으로 인한 대량 로깅된 작업에 의해 수정된 익스텐트들을 추적한다. 비트로 수정여부를 나타 낸다. BCM페이지들이 모든 DB에서 나타나지만, DB가 대량 로그 복구 모델을 사용할때만 관련이 있다. 복구모델에서 BACKUP LOG 구문이 수행 되면 백업 프로세스는 수정된 익스텐트를 찾기 위해 BCM페이지를 스캔한다. 그러면 로그 백업에서 그 익스텐트들을 포함한다. 이는 DB가 백업과 일련의 트랜잭션 로그 백업으로부터 복구되면 대량 작업들을 복구한다. BCM페이지는 단순 복구 모델을 사용하는 DB와는 관련이 없는데 대량 로깅된 작업들이 없기 떄문이다. 완전 복구 모델을 사용하는 DB와도 관련이 없는 데 대량 로깅 된 작업들을 완전히 로깅된 작업으로 취급하기 떄문이다(?)

DCM페이지들과 BCM페이지들간의 간격은 GAM과 SGAM간의 간격(6만4천 익스텐트)와 같다. DCM과 BCM페이지는 물리적 파일 내에서 GAM과SGAM페이지 뒤에 존재한다.

![DCM/BCM 다이어그램](https://learn.microsoft.com/en-us/sql/relational-databases/media/pages-and-extents-architecture-guide/special-page-order.svg?view=sql-server-2017)

#### 참조

- [MSDN : Pages and extents architecture guide](https://learn.microsoft.com/en-us/sql/relational-databases/pages-and-extents-architecture-guide?view=sql-server-2017)
